policy_module(incus)
## <desc>
##	<p>
##	Allow incusd to mount filesystems inside
##	lxc containers that might be required
##	by some legacy init systems.
##	</p>
## </desc>
gen_tunable(incus_lxc_legacy_mounts, false)

########################################
#
# Declarations
#

# common attribute for all container domains
# that may be used with incus
attribute incus_container_domain;

container_engine_domain_template(incusd)
container_system_engine(incusd_t)
type incusd_exec_t;

container_engine_executable_file(incusd_exec_t)

init_daemon_domain(incusd_t, incusd_exec_t)

ifdef(`enable_mls',`
	init_ranged_daemon_domain(incusd_t, incusd_exec_t, s0 - mls_systemhigh)
')

type incusc_t;
type incusc_exec_t;

container_engine_executable_file(incusc_exec_t)
application_domain(incusc_t, incusc_exec_t)

# other engines like docker have this, what will it do?
#container_engine_domain_template(incusd_user)

# user containers are not tested yet
#container_user_engine(incusd_user_t)
#application_domain(incusd_user_t, incusd_exec_t)

#mls_trusted_object(incusd_user_t)

type incusc_user_t;
application_domain(incusc_user_t, incusc_exec_t)

########################################
#
# incus daemon local policy

allow incusd_t self:process getattr;
allow incusd_t self:anon_inode { create map read write };
allow incusd_t self:io_uring sqpoll;
allow incusd_t self:netlink_kobject_uevent_socket create_socket_perms;
allow incusd_t self:vsock_socket create_stream_socket_perms;
dontaudit incusd_t self:capability sys_module;

# incusd needs to manage the host network
allow incusd_t self:rawip_socket { create getopt ioctl read setopt write };
allow incusd_t self:tun_socket { create relabelfrom relabelto };

# incusd wants to load netdev-phys*
kernel_request_load_module(incusd_t)

ifdef(`init_systemd',`
	init_start_system(incusd_t)
	init_stop_system(incusd_t)
	init_get_system_status(incusd_t)
	init_stop_generic_units(incusd_t)
')

# losetup required for instance creation
dev_rw_loop_control(incusd_t)
dev_rw_vhost(incusd_t)

# comm="incusd" path="/run/systemd/resolve/stub-resolv.conf"
container_read_tmpfs_files(incusd_t)

fs_getattr_binfmt_misc_fs(incusd_t)
fs_mount_binfmt_misc_fs(incusd_t)
fs_getattr_binfmt_misc_dirs(incusd_t)
fs_dontaudit_manage_fusefs_files(incusd_t)

# here dontaudit would also work, but consuming more resources
fs_watch_tmpfs_dirs(incusd_t)

dnsmasq_domtrans(incusd_t)
dnsmasq_signal(incusd_t)
dnsmasq_kill(incusd_t)
dnsmasq_signull(incusd_t)

kernel_setsched(incusd_t)
optional_policy(`
	dpkg_dontaudit_manage_db(incusd_t)
')

files_exec_usr_files(incusd_t)

iptables_domtrans(incusd_t)
iptables_kill(incusd_t)

mount_exec(incusd_t)

rsync_exec(incusd_t)

# avc:  denied  { read } for  pid=20404 comm="qemu-system-x86"
# name="overcommit_memory" dev="proc" ino=16557
# scontext=system_u:system_r:incusd_t:s0
# tcontext=system_u:object_r:sysctl_vm_overcommit_t:s0 tclass=file permissive=0
kernel_read_vm_overcommit_sysctl(incusd_t)

# for bridge management
dev_create_sysfs_files(incusd_t)
dev_write_sysfs(incusd_t)

# incusd won't start without access to /dev/urandom
dev_read_urand(incusd_t)

# mounton access to /proc/sys/kernel/random/boot_id
kernel_mounton_kernel_sysctl_files(incusd_t)

# read /etc/machine-id
files_read_etc_runtime_files(incusd_t)

# incus apparmor support wants to handle /sys/kernel/tracing
fs_dontaudit_getattr_tracefs(incusd_t)
fs_dontaudit_getattr_tracefs_dirs(incusd_t)
fs_dontaudit_remount_tracefs(incusd_t)

# reason for access not (yet?) looked up in the source code
# but everything seems to work fine so far
fs_dontaudit_getattr_configfs(incusd_t)
fs_dontaudit_remount_configfs(incusd_t)

# required for fanotify on /dev/zvol/zdata/incus/virtual-machines/.#vm1.block...
dev_watch_dev_fs(incusd_t)

# required so that incus will get the VM PID
# and make 'incus info VM' work
# Error: stat /proc/628420: permission denied
qemu_read_state(incusd_t)

tunable_policy(`incus_lxc_legacy_mounts',`
	fs_getattr_binfmt_misc_fs(incusd_t)

	kernel_getattr_debugfs(incusd_t)
	kernel_search_debugfs(incusd_t)
	kernel_remount_debugfs(incusd_t)

	fs_getattr_efivarfs(incusd_t)
	fs_remount_efivarfs(incusd_t)

	fs_getattr_pstorefs(incusd_t)
	fs_remount_pstorefs(incusd_t)
')

fs_dontaudit_getattr_binfmt_misc_fs(incusd_t)

fs_dontaudit_getattr_efivarfs(incusd_t)
fs_dontaudit_remount_efivarfs(incusd_t)

fs_dontaudit_getattr_pstorefs(incusd_t)
fs_dontaudit_remount_pstorefs(incusd_t)

kernel_dontaudit_getattr_debugfs(incusd_t)
kernel_dontaudit_search_debugfs(incusd_t)
kernel_dontaudit_remount_debugfs(incusd_t)

# incus idmap support: checks whether the kernel supports VFS v3 fscaps
container_execute_engine_tmp_files(incusd_t)

# required for QEMU feature check, won't start otherwise
files_rw_generic_tmp_sockets(incusd_t)
files_dontaudit_unlink_generic_tmp_sockets(incusd_t)

qemu_stream_connect(incusd_t)
qemu_kill(incusd_t)
dev_getattr_vhost_dev(incusd_t)

# these are required for incusd to check and execute qemu
qemu_domtrans(incusd_t)
qemu_exec(incusd_t)

# incusd needs support to label VM files before launching
# until then, VM files will unfortunately be unlabeled
kernel_manage_unlabeled_dirs(incusd_t)
kernel_manage_unlabeled_files(incusd_t)
kernel_manage_unlabeled_symlinks(incusd_t)
kernel_mounton_unlabeled_dirs(incusd_t)
files_search_default(incusd_t)

# name="stub-resolv.conf"
fs_read_tmpfs_files(incusd_t)

########################################
#
# incus lxc container local policy

allow incus_container_domain self:cap_userns { chown dac_override dac_read_search fowner fsetid kill net_admin net_bind_service net_raw setgid setpcap setuid sys_admin sys_boot sys_chroot sys_ptrace };

container_manage_engine_tmpfs_dirs(incus_container_domain)
container_manage_engine_tmpfs_files(incus_container_domain)
container_manage_engine_tmpfs_symlinks(incus_container_domain)

